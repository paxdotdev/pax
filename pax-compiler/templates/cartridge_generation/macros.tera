{%- macro render_component_factory(component) %}
struct {{component.pascal_identifier}}Factory{}

impl ComponentFactory for {{component.pascal_identifier}}Factory {

    fn build_default_properties(&self) -> Box<dyn Fn(Rc<RuntimePropertiesStackFrame>, Rc<ExpressionTable>) -> Rc<RefCell<dyn Any>>> {
        Box::new(|_,_| Rc::new(RefCell::new({{component.pascal_identifier}}::default())))
    }

    fn build_inline_properties(&self, defined_properties: HashMap<String,ValueDefinition>) -> Box<dyn Fn(Rc<RuntimePropertiesStackFrame>, Rc<ExpressionTable>) -> Rc<RefCell<dyn Any>>> {
        Box::new(move |stack_frame , table | Rc::new(RefCell::new(
            {
        let mut properties = {{component.pascal_identifier}}::default();
        {% for property in component.properties %}
            if let Some(vd) = defined_properties.get("{{property.name}}") {
                properties.{{property.name}}.replace_with(
                    match vd.clone() {
                        ValueDefinition::LiteralValue(lv) => {
                            {% if property.property_type.type_id.is_intoable_downstream_type %}
                                let mi = from_pax_try_intoable_literal(&lv.raw_value);
                                if let Ok(intoable_literal) = mi {
                                    Property::new_with_name(intoable_literal.into(), &lv.raw_value)
                                } else {
                                    Property::new_with_name(from_pax::<{{property.property_type.type_id._type_id}}>(&lv.raw_value).unwrap().into(), &lv.raw_value)
                                }
                            {% else %}
                                Property::new_with_name(from_pax::<{{property.property_type.type_id._type_id}}>(&lv.raw_value).unwrap().into(), &lv.raw_value)
                            {% endif %}
                        },
                        ValueDefinition::Expression(token, info) | ValueDefinition::Identifier(token,info) =>
                        {
                            if let Some(info) = info {
                                let mut dependents = vec![];
                                for dependency in &info.dependencies {
                                    if let Some(p) = stack_frame.resolve_symbol_as_erased_property(dependency) {
                                        dependents.push(p);
                                    } else {
                                        panic!("Failed to resolve symbol {}", dependency);
                                    }
                                }
                                let cloned_stack = stack_frame.clone();
                                let cloned_table = table.clone();
                                Property::computed_with_name(move || {
                                    let new_value_wrapped: Box<dyn Any> = cloned_table.compute_vtable_value(&cloned_stack, info.vtable_id.clone());
                                    if let Ok(downcast_value) = new_value_wrapped.downcast::<{{property.property_type.type_id._type_id}}>() {
                                        *downcast_value
                                    } else {
                                        panic!(
                                            "property has an unexpected type for vtable id {}",
                                            info.vtable_id
                                        );
                                    }
                                
                                }, &dependents, &token.raw_value)
                            } else {
                                unreachable!("No info for expression")
                            }
                        },
                        ValueDefinition::Block(block) => {
                            Property::new_with_name({{property.property_type.type_id._type_id_escaped}}TypeFactory{}.build_type(&block, stack_frame.clone(), table.clone()), "block")
                        }
                        _ => unreachable!("Invalid value definition for {{property.name}}")
                    });
            }
        {% endfor %}
        properties
        })))
    }

    fn build_handler(&self,fn_name: &str) -> fn(Rc<RefCell<dyn Any>>, &NodeContext, Option::<Box<dyn Any>>) {
        match fn_name {
            {% for handler in component.handlers %}
            "{{handler.name}}" => {
                |properties, ctx, args|{
                    let properties = &mut *properties.as_ref().borrow_mut();
                    if let Some(mut properties) = properties.downcast_mut::<{{component.pascal_identifier}}>() {
                        // downcast args to handler.type
                        {% if handler.args_type %}
                            if let Some(args) = args {
                                if let Some(args) = args.downcast_ref::<{{handler.args_type}}>() {
                                    {{component.pascal_identifier}}::{{handler.name}}(properties,ctx, args.clone());
                                } else {panic!("Failed to downcast args to {{handler.args_type}}")};
                            } else {
                                panic!("No {{handler.args_type}} present");
                            }
                        {% else %}
                            if let None = args {
                                {{component.pascal_identifier}}::{{handler.name}}(properties,ctx);
                            } else {
                                panic!("Unexpected args present");
                            }
                        {% endif %}
                        
                    } else {panic!("Failed to downcast properties to {{component.pascal_identifier}}")};
                }
            },
            {% endfor %}
            _ => panic!("Unknown handler name {}", fn_name)
        }
    }

    fn build_component_handlers(&self, handlers: Vec<(String, Vec<String>)>) -> Rc<RefCell<HandlerRegistry>> {
        let mut handler_registry = HandlerRegistry::default();
        for (event, functions) in &handlers {
            handler_registry.handlers.insert(event.clone(), functions.iter().map(|fn_name| {
                Handler::new_component_handler(self.build_handler(&fn_name))
            }).collect());
        } 
        Rc::new(RefCell::new(handler_registry))
    }

    fn add_inline_handlers(&self, handlers: Vec<(String, String)>, handler_registry: Rc<RefCell<HandlerRegistry>>) -> Rc<RefCell<HandlerRegistry>> {
        {
            let mut handler_registry_mut = handler_registry.borrow_mut();
            for (event, fn_name) in &handlers {
                let handler_vec = handler_registry_mut.handlers.entry(event.clone()).or_insert(Vec::new());
                handler_vec.push(Handler::new_inline_handler(self.build_handler(&fn_name)));
            } 
        }   
        handler_registry
    }

    fn build_compute_properties_fn(&self) -> Option<Box<dyn Fn(&ExpandedNode, &ExpressionTable, &Globals)>> {
        Some(Box::new(|node, table, globals|{
            let props = &node.properties.borrow();
            let properties = &mut props.as_ref().borrow_mut();

            if let Some(properties) = properties.downcast_mut::<{{component.pascal_identifier}}>() {

                {% for prop in component.properties %}
                    // TODODAG: this entire method can be removed?
                    // possible backup plan could be to make this the function that actually connects up the properties,
                    // and before that leave them in a dummy state (in this method we clearly have what we need: expr table, stack, etc)

                    // if let Some(new_value) = table.compute_eased_value(properties.{{prop.name}}._get_transition_manager(), globals) {
                    //     properties.{{ prop.name }}.set(new_value);
                    // } else if let Some(vtable_id) = properties.{{ prop.name }}._get_vtable_id() {
                    //     let new_value_wrapped = table.compute_vtable_value(&node.stack, vtable_id);
                    //     if let Ok(new_value) = new_value_wrapped.downcast::<{{prop.property_type.type_id._type_id}}>() {
                    //         properties.{{ prop.name }}.set(*new_value);
                    //     } else {
                    //         panic!(
                    //             "generated code tried to downcast to incompatible type \"{{prop.property_type.type_id._type_id}}\" for property \"{{prop.name}}\" on {{component.pascal_identifier}}"
                    //         );
                    //     }
                    // }
                {% endfor %}

            } else {
                panic!("Failed to downcast properties to {{component.pascal_identifier}}");
            }
        }))
    }

    fn build_component(&self, args: InstantiationArgs) -> Rc<dyn InstanceNode> {
        {% if component.primitive_instance_import_path%}
        {{component.primitive_instance_import_path}}::instantiate(args)
        {% else %}
        ComponentInstance::instantiate(args)
        {% endif %}    
    }

    fn get_properties_scope_factory(&self) -> Box<dyn Fn(Rc<RefCell<dyn Any>>) -> HashMap<String, ErasedProperty>>  {
        Box::new(|props| {
            let properties = &mut props.as_ref().borrow_mut();
            if let Some(properties) = properties.downcast_mut::<{{component.pascal_identifier}}>() {
                let mut scope = HashMap::new();
                {% for prop in component.properties %}
                    scope.insert("{{prop.name}}".to_string(), properties.{{prop.name}}.erase());
                {% endfor %}
                scope
            } else {
                panic!("Failed to downcast properties to {{component.pascal_identifier}}");
            }
        })
    }

}
{%- endmacro -%}

{%- macro render_type_factory(type_table, active_type) %}
#[allow(non_camel_case_types)]
struct {{active_type.type_id._type_id_escaped}}TypeFactory{}

impl TypeFactory for {{active_type.type_id._type_id_escaped}}TypeFactory {

    type Output={{active_type.type_id._type_id}};

    fn build_type(&self, args: &LiteralBlockDefinition, stack_frame: Rc<RuntimePropertiesStackFrame>, table: Rc<ExpressionTable>) -> Self::Output {
        let mut properties: {{active_type.type_id._type_id}} = Default::default();
        for setting in &args.elements {
            if let SettingElement::Setting(k, vd) = setting {
                match k.raw_value.as_str() {
                    {% for prop in active_type.property_definitions %}
                    "{{prop.name}}" => {
                        {% if not prop.flags.is_enum %}
                            properties.{{prop.name}} = 
                            {% if prop.flags.is_property_wrapped %}
                                match vd {
                                    ValueDefinition::LiteralValue(lv) => {


                                        {% if prop.property_type.type_id.is_intoable_downstream_type %}
                                            let mi = from_pax_try_intoable_literal(&lv.raw_value);
                                            if let Ok(intoable_literal) = mi {
                                                Property::new_with_name(intoable_literal.into(), &lv.raw_value)
                                            } else {
                                                if let Err(e) = from_pax::<{{prop.type_id._type_id}}>(&lv.raw_value) {
                                                    panic!("Failed to parse value for {} with error {}", &lv.raw_value, e);
                                                }
                                                Property::new_with_name(from_pax::<{{prop.type_id._type_id}}>(&lv.raw_value).unwrap(), &lv.raw_value)
                                            }
                                        {% else %}
                                            Property::new_with_name(from_pax::<{{prop.type_id._type_id}}>(&lv.raw_value).unwrap(), &lv.raw_value)
                                        {% endif %}
                                    },
                                    ValueDefinition::Expression(token, info) | ValueDefinition::Identifier(token, info ) =>
                                    {
                                        if let Some(info) = info {
                                            let mut dependents = vec![];
                                            for dependency in &info.dependencies {
                                                if let Some(p) = stack_frame.resolve_symbol_as_erased_property(dependency) {
                                                    dependents.push(p);
                                                } else {
                                                    panic!("Failed to resolve symbol {}", dependency);
                                                }
                                            }
                                            let cloned_stack = stack_frame.clone();
                                            let cloned_table = table.clone();
                                            let cloned_info = info.clone();
                                            Property::computed_with_name(move || {
                                                let new_value_wrapped: Box<dyn Any> = cloned_table.compute_vtable_value(&cloned_stack, cloned_info.vtable_id);
                                                if let Ok(downcast_value) = new_value_wrapped.downcast::<{{prop.type_id._type_id}}>() {
                                                    *downcast_value
                                                } else {
                                                    panic!(
                                                        "property has an unexpected type for vtable id {}",
                                                        cloned_info.vtable_id
                                                    );
                                                }
                                            
                                            }, &dependents, &token.raw_value)
                                        } else {
                                            unreachable!("No info for expression")
                                        }
                                    },
                                    ValueDefinition::Block(block) => {
                                        Property::new_with_name({{prop.type_id._type_id_escaped}}TypeFactory{}.build_type(&block, stack_frame.clone(), table.clone()), "block")
                                    }
                                    _ => unreachable!("Invalid value definition for {{prop.name}}")
                                };
                            {% else %}
                                match vd {
                                    ValueDefinition::LiteralValue(lv) => {

                                        {% if prop.property_type.type_id.is_intoable_downstream_type %}
                                            let mi = from_pax_try_intoable_literal(&lv.raw_value);
                                            if let Ok(intoable_literal) = mi {
                                                Property::new_with_name(intoable_literal.into(), &lv.raw_value)
                                            } else {
                                                from_pax(&lv.raw_value).unwrap()
                                            }
                                        {% else %}
                                            from_pax(&lv.raw_value).unwrap()
                                        {% endif %}
                                    },
                                    ValueDefinition::Block(block) => {
                                        {{prop.type_id._type_id_escaped}}TypeFactory{}.build_type(args, stack_frame.clone(), table.clone())
                                    }
                                    _ => unreachable!("Invalid value definition for {{prop.name}}")
                                };
                            {% endif %}
                        {% endif %}
                    },
                    {% endfor %}
                    _ => panic!("Unknown property name {}", k.raw_value)
                }
            
            }
        }
        properties
    }
}

{%- endmacro -%}
