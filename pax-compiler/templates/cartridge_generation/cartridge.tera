{% import "macros.tera" as macros %}

use pax_engine::api as pax_runtime_api;
use pax_engine::pax_runtime::InstanceNode;
use pax_engine::pax_runtime::DefinitionToInstanceTraverser;
use pax_engine::api::pax_value::ToFromPaxAny;
use pax_engine::pax_lang::Computable;

use_RefCell!();

fn init_cartridge() -> Box<dyn pax_engine::pax_runtime::cartridge::PaxCartridge> {
    Box::new({{ cartridge_struct_id }} {})
}

fn init_manifest() -> pax_manifest::PaxManifest {
    let manifest_json = r#######"{{manifest_json}}"#######;
    let manifest: pax_manifest::PaxManifest = pax_engine::serde_json::from_str(manifest_json).unwrap();
    manifest
}

fn init_definition_to_instance_traverser(initial_manifest: pax_manifest::PaxManifest) -> Box<dyn pax_engine::pax_runtime::cartridge::DefinitionToInstanceTraverser> {
    Box::new({{ definition_to_instance_traverser_struct_id }}::new(initial_manifest))
}

pub struct {{ cartridge_struct_id }} {}

impl pax_engine::pax_runtime::cartridge::PaxCartridge for {{ cartridge_struct_id }} {
}
{% for c in components -%}
    {{ macros::render_component_factory(component=c) }}
{%- endfor %}

trait TypeFactory {
    type Output: Default + Clone;
    
    fn build_type(&self, args: &pax_engine::pax_manifest::LiteralBlockDefinition, stack_frame: std::rc::Rc<pax_engine::pax_runtime::RuntimePropertiesStackFrame>, table: std::rc::Rc<pax_engine::pax_runtime::ExpressionTable>) -> Self::Output;
}
{% for key, value in type_table -%}
    {{ macros::render_type_factory(type_table=type_table, active_type=value) }}
    {% if value.type_id.pax_type.Singleton %}
    {% endif %}
{%- endfor %}

pub struct {{ definition_to_instance_traverser_struct_id }} {
    #[cfg(not(feature = "designtime"))]
    manifest: pax_engine::pax_manifest::PaxManifest,
    #[cfg(feature = "designtime")]
    designtime_manager: std::rc::Rc<RefCell<pax_designtime::DesigntimeManager>>,
}

impl pax_engine::pax_runtime::DefinitionToInstanceTraverser for {{ definition_to_instance_traverser_struct_id }} {

    fn get_component_factory(&self, type_id: &pax_engine::pax_manifest::TypeId) -> Option<Box<dyn pax_engine::pax_runtime::cartridge::ComponentFactory>> {
        if type_id.is_blank_component() {
            return Some(Box::new(BlankComponentFactory{}) as Box<dyn pax_engine::pax_runtime::ComponentFactory>);
        }

        match type_id.get_unique_identifier().as_str() {
            {% for component in components %}
            "{{component.type_id._type_id}}" => {
                Some(Box::new({{component.pascal_identifier}}Factory{}) as Box<dyn pax_engine::pax_runtime::ComponentFactory>)
            },
            {% endfor %}
            _ => None
        }
    }


    #[cfg(not(feature = "designtime"))]
    fn new(manifest: pax_manifest::PaxManifest) -> Self {
        Self {
            manifest,
        }
    }
    #[cfg(feature = "designtime")]
    fn new(manifest: pax_manifest::PaxManifest) -> Self {
        let designtime_manager = std::rc::Rc::new(RefCell::new(pax_designtime::DesigntimeManager::new(manifest)));
        Self {
            designtime_manager,
        }
    }

    #[cfg(not(feature = "designtime"))]
    fn get_manifest(&self) ->  &pax_manifest::PaxManifest {
        &self.manifest
    }
    #[cfg(feature = "designtime")]
    fn get_manifest(&self) ->  std::cell::Ref<pax_manifest::PaxManifest> {
        std::cell::Ref::map(borrow!(self.designtime_manager), |manager| {
            manager.get_manifest()
        })
    }

    #[cfg(feature = "designtime")]
    fn get_designtime_manager(&self, project_query: String) -> std::option::Option<std::rc::Rc<RefCell<pax_designtime::DesigntimeManager>>> {
        borrow_mut!(self.designtime_manager).set_project(project_query);
        Some(self.designtime_manager.clone())
    }
}
