use std::cell::RefCell;
use std::rc::Rc;

//Component types
#[repr(C)]
#[derive(Default)]
pub enum PropertiesCoproduct {
    /* entries generated via properties-coproduct-lib.tera */
    #[default]
    None,
    Repeat(RepeatProperties),
    Slot(SlotProperties),
    Conditional(ConditionalProperties),
    RepeatItem(Rc<PropertiesCoproduct>, usize),
    #[allow(non_camel_case_types)]
    isize(isize),
    #[allow(non_camel_case_types)]
    stdCOCOopsCOCORangeLABRisizeRABR(std::ops::Range<isize>),

    {% for properties_coproduct_tuple in properties_coproduct_tuples %}
    #[allow(non_camel_case_types)]
    {{properties_coproduct_tuple.0}}({{properties_coproduct_tuple.1}}),
    {% endfor %}
}

//Property types
#[repr(C)]
pub enum TypesCoproduct {
    {% for types_coproduct_tuple in types_coproduct_tuples %}
    #[allow(non_camel_case_types)]
    {{types_coproduct_tuple.0}}({{types_coproduct_tuple.1}}),
    {% endfor %}
}


///Contains modal _vec_ and _range_ variants, describing whether the Repeat source
///is encoded as a Vec<T> (where T is a PropertiesCoproduct type) or as a Range<isize>
pub struct RepeatProperties {
    pub repeat_source_expression_vec: Option<Box<dyn PropertyInstance<Vec<Rc<PropertiesCoproduct>>>>>,
    pub repeat_source_expression_range: Option<Box<dyn PropertyInstance<std::ops::Range<isize>>>>,
}

pub struct SlotProperties {
    pub index: Box<dyn PropertyInstance<pax_runtime_api::Numeric>>,
}

pub struct ConditionalProperties {
    pub boolean_expression: Box<dyn PropertyInstance<bool>>,
}