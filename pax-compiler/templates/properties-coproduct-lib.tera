use std::cell::RefCell;
use std::rc::Rc;

//Component types
#[repr(C)]
#[derive(Default)]
pub enum PropertiesCoproduct {
    /* entries generated via properties-coproduct-lib.tera */
    #[default]
    None,
    Repeat(RepeatProperties),
    Slot(SlotProperties),
    Conditional(ConditionalProperties),
    RepeatItem(Rc<RefCell<PropertiesCoproduct>>, usize),
    #[allow(non_camel_case_types)]
    isize(isize),
    #[allow(non_camel_case_types)]
    stdCOCOopsCOCORangeLABRisizeRABR(std::ops::Range<isize>),

    {% for properties_coproduct_tuple in properties_coproduct_tuples %}
    #[allow(non_camel_case_types)]
    {{properties_coproduct_tuple.0}}({{properties_coproduct_tuple.1}}),
    {% endfor %}
}

//Property types
#[repr(C)]
pub enum TypesCoproduct {
    {% for types_coproduct_tuple in types_coproduct_tuples %}
    #[allow(non_camel_case_types)]
    {{types_coproduct_tuple.0}}({{types_coproduct_tuple.1}}),
    {% endfor %}
}

///Contains modal _vec_ and _range_ variants, describing whether the Repeat source
///is encoded as a Vec<T> (where T is a PropertiesCoproduct type) or as a Range<isize>
pub struct RepeatProperties {
    pub source_expression_vec: Option<Box<dyn pax_runtime_api::PropertyInstance<Vec<Rc<RefCell<PropertiesCoproduct>>>>>>,
    pub source_expression_range: Option<Box<dyn pax_runtime_api::PropertyInstance<std::ops::Range<isize>>>>,
}

///Contains the index value for slot, either a literal or an expression.
pub struct SlotProperties {
    pub index: Box<dyn pax_runtime_api::PropertyInstance<pax_runtime_api::Numeric>>,
}

///Contains the expression of a conditional, evaluated as an expression.
pub struct ConditionalProperties {
    pub boolean_expression: Box<dyn pax_runtime_api::PropertyInstance<bool>>,
}
