 #![allow(unused, unused_imports, non_snake_case, unused_parens)]

// generate imports, pointing to userland cartridge `pub mod pax_reexports`
{% for import in imports %}
use {{ import }};
{% endfor %}

//pull in entire const token stream here e.g. `const JABBERWOCKY : &str = r#"â€™Twas brillig, and the slithy toves `...
{% for const in consts %}
    {{ const }}
{% endfor %}

pub fn instantiate_expression_table<R: 'static + RenderContext>() -> HashMap<usize, Box<dyn Fn(ExpressionContext<R>) -> Box<dyn Any>>> {
    let mut vtable: HashMap<usize, Box<dyn Fn(ExpressionContext<R>) -> Box<dyn Any>>> = HashMap::new();

    {% for expression_spec in expression_specs %}
    //{{ expression_spec.input_statement.content}}
    {% if expression_spec.input_statement.source_map_start_marker %}
        {{ expression_spec.input_statement.source_map_start_marker }}
    {% endif %}
    vtable.insert({{ expression_spec.id }}, Box::new(|ec: ExpressionContext<R>| -> Box<dyn Any> {
        {% for invocation in expression_spec.invocations %}
            let {{ invocation.escaped_identifier }} =
            {
                let properties = if let Some(sf) = (*ec.stack_frame).borrow().peek_nth({{ invocation.stack_offset }}) {
                    Rc::clone(&sf)
                } else {
                    Rc::clone(&ec.stack_frame)
                }.borrow().deref().get_properties();
                let mut borrowed = &mut *(*properties).borrow_mut();
                {% if invocation.property_flags.is_binding_repeat_elem %}
                    // binding repeat elem
                    if let Some(unwrapped_repeat_item) = borrowed.downcast_ref::<RepeatItem>() {
                        let i = unwrapped_repeat_item.i;
                        let elem = Rc::clone(&unwrapped_repeat_item.elem);

                        {% if invocation.is_numeric %}
                            //iterable numeric as `elem`
                            get_numeric_from_wrapped_properties(elem)
                        {% elif invocation.is_string %}
                            //string as `elem`

                            let elem_borrowed = elem.borrow();
                            if let Some(unwrapped) = elem_borrowed.downcast_ref::<{{invocation.fully_qualified_iterable_type}}>() {
                                StringBox::from(unwrapped)
                            } else {
                                panic!();//Failed to unpack string from dyn Any
                            }

                        {% elif invocation.is_bool %}
                            //bool as `elem`
                            elem.clone()
                        {% else %}
                            //iterable complex type
                            let mut elem_borrowed = elem.borrow_mut();
                            if let Some(dc) = elem_borrowed.downcast_mut::<{{invocation.fully_qualified_iterable_type}}>() {
                                dc.clone()
                            } else {unreachable!()}
                        {% endif %}
                    } else {panic!()} // Failed to downcast


                {% elif invocation.property_flags.is_binding_repeat_i %}
                    //binding repeat i
                    let mut unwrapped_repeat_item = if let Some(val) = borrowed.downcast_mut::<RepeatItem>() {val} else {panic!()}; // Failed to downcast
                    let i = unwrapped_repeat_item.i;
                    Numeric::from(i)
                {% else %}

                    if let Some(p) = borrowed.downcast_ref::<{{invocation.fully_qualified_properties_struct_type}}>(){

                        {% if invocation.is_numeric %}
                            //binding simple numeric property
                            Numeric::from(p.{{invocation.root_identifier}}.get())
                        {% elif invocation.is_string %}
                            //binding simple stringbox property
                            StringBox::from(p.{{invocation.root_identifier}}.get())
                        {% else %}
                            //binding cloneable property
                            p.{{invocation.root_identifier}}.get().clone()
                        {% endif %}
                    } else {unreachable!()}
                {% endif %}
            }{{ invocation.nested_symbol_tail_literal }};
            {% if invocation.is_nested_numeric %}
                let {{ invocation.escaped_identifier }} = Numeric::from( {{ invocation.escaped_identifier }} );
            {% endif %}

        {% endfor %}

        {% if expression_spec.is_repeat_source_iterable_expression %}
            {# We have a Vec<T>, like a Vec<StackerCell>, and we need to rewrap it into a Vec<Rc<RefCell<dyn Any>>> for Repeat #}
            {% for invocation in expression_spec.invocations %}
                let {{ invocation.escaped_identifier }} = {{ invocation.escaped_identifier }}.iter().map(|t|{
                    let converted_cell: Rc<RefCell<(dyn Any + 'static)>> = Rc::new(RefCell::new(t.clone()));
                    converted_cell
                }).collect::<Vec<Rc<RefCell<dyn Any>>>>();
            {% endfor %}
        {% endif %}


        //TODOSAM this is where to add special casing for the string output

        Box::new({{expression_spec.output_statement}})

    }));
    {% if expression_spec.input_statement.source_map_end_marker %}
        {{ expression_spec.input_statement.source_map_end_marker }}
    {% endif %}
    {% endfor %}

    vtable
}

//Begin component factory literals
{% for factory_literal in component_factories_literal %}
    {{ factory_literal }}
{% endfor %}
