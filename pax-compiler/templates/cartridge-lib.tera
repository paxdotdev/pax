
//Prelude: Rust
use std::cell::RefCell;
use std::collections::{HashMap, VecDeque};
use std::ops::Deref;
use std::rc::Rc;
//Prelude: Pax
use pax_runtime_api::numeric::Numeric;
use pax_runtime_api::{ArgsCoproduct, Size, SizePixels, PropertyInstance, PropertyLiteral, Size2D, Transform2D};
use pax_core::{ComponentInstance, RenderNodePtr, PropertyExpression, RenderNodePtrList, RenderTreeContext, ExpressionContext, PaxEngine, RenderNode, InstanceRegistry, HandlerRegistry, InstantiationArgs, ConditionalInstance, SlotInstance, StackFrame};
use pax_core::pax_properties_coproduct::{PropertiesCoproduct, TypesCoproduct};
use pax_core::repeat::{RepeatInstance};
use piet_common::RenderContext;

// generate imports, pointing to userland cartridge `pub mod pax_reexports`
{% for import in imports %}
use {{ import }};
{% endfor %}

//pull in entire const token stream here e.g. `const JABBERWOCKY : &str = r#"â€™Twas brillig, and the slithy toves `...
{% for const in consts %}
    {{ const }}
{% endfor %}

pub fn instantiate_expression_table<R: 'static + RenderContext>() -> HashMap<usize, Box<dyn Fn(ExpressionContext<R>) -> TypesCoproduct>> {
    let mut vtable: HashMap<usize, Box<dyn Fn(ExpressionContext<R>) -> TypesCoproduct>> = HashMap::new();

    {% for expression_spec in expression_specs %}
    //{{ expression_spec.input_statement}}
    vtable.insert({{ expression_spec.id }}, Box::new(|ec: ExpressionContext<R>| -> TypesCoproduct {
        {% for invocation in expression_spec.invocations %}
            let {{ invocation.escaped_identifier }} = {
                let properties = if let Some(sf) = (*ec.stack_frame).borrow().nth_ancestor({{ invocation.stack_offset }}) {
                    Rc::clone(&sf)
                } else {
                    Rc::clone(&ec.stack_frame)
                }.borrow().deref().get_properties();
                let properties = &*(*properties).borrow();

                {% if invocation.is_repeat_elem or invocation.is_repeat_index %}
                    if let PropertiesCoproduct::RepeatItem(elem, i) = properties {
                        {% if invocation.is_repeat_elem %}
                            {% if invocation.is_iterable_numeric %}
                                {# For known numeric primitives, we can safely deref-copy and wrap in Numeric #}
                                let unwrapped = if let PropertiesCoproduct::{{invocation.pascalized_iterable_type}}(i) = **elem {i} else {unreachable!()};
                                Numeric::from(unwrapped)
                            {% elif invocation.is_iterable_primitive_nonnumeric %}
                                {# Currently, only String #}
                                elem.clone()
                            {% else %}
                                {# This should be iterating over a `Rc<PropertiesCoproduct>`, so pass that forward for chained unwrapping #}
                                Rc::clone(elem)
                            {% endif %}
                        {% else %}
                            {# We're binding to `i`, an index, so wrap it in `Numeric` #}
                            Numeric::from(*i)
                        {% endif %}

                    } else {unreachable!()}
                {% else %}
                    if let PropertiesCoproduct::{{ invocation.properties_type }}(p) = properties {
                            p.{{invocation.identifier}}.get().clone()
                    } else {
                        unreachable!("{{ expression_spec.id }}")
                    }
                {% endif %}
            };
        {% endfor %}

        #[allow(unused_parens)]
        TypesCoproduct::{{ expression_spec.pascalized_return_type }}(
            {{ expression_spec.output_statement }}
        )
    }));
    {% endfor %}

    vtable
}

//Begin component factory literals
{% for factory_literal in component_factories_literal %}
    {{ factory_literal }}
{% endfor %}
