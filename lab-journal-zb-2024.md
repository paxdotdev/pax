
### 2024-08 - Initializing pax-designer

[x] Merge / rebase expression interpreting
# back up branch
git checkout -b zb/designer-bak-00

    migrating paxcorp/pax-designer to pax/pax-designer, including range of commits 561666d08256e52f967a6d59a3948175181cbf71 to 7767d5d4396ac8023cc456d6dda63151e076cd04 (inclusive)
    migrating paxcorp/pax-design-server to pax/pax-design-server, including range of commits 02ae043657ec1bf6053af0ad2de98041f20f6bee to 137ea86a1e27bbc84530c670f53291d784c80047 (inclusive)
    
    cd /Users/zack/code/paxcorp
    git format-patch 561666d08256e52f967a6d59a3948175181cbf71~1..HEAD --stdout -- pax-designer > pax-designer.patch
    git format-patch 02ae043657ec1bf6053af0ad2de98041f20f6bee~1..HEAD --stdout -- pax-design-server > pax-design-server.patch
    
    Apply patches: [see Solution]
    
    [error, patch does not apply]
    next to try: extract my local commits to patch; apply in the other direction on latest master
    
    [Solution] 
    git apply --3way ../pax-designer.patch
    git apply --3way ../pax-design-server.patch
    
    [ ] Update init logic, two manifests, two designtimes on other side of serialization
    
    git checkout main  # or the branch where pax-designtime exists
    git subtree split -P pax-designtime -b temp-pax-designtime


[ ] Init logic
    [x] Macro init logic (compiletime)
        [x] Issue: can't export pax_engine::pax_designer (circ. ref., because pax-designer depends on pax-engine)
            - could import pax-designer directly from userland, but adds to boilerplate
                seems most viable so far — maybe even correct to require `pax-designer` as a dev dependency when you intend to use it.
                we can handle generating this boilerplate for new projects, and carefully document it.  
                ^ trying the above
                now hitting an issue where the `pax_designer` crate (as generated by macro) doesn't exist within the `pax_designer` crate
                one possibility is to detect at macro-time whether we're in a whitelisted crate
            - could pre-parse pax-designer to manifest, including the manifest string as a compiler artifact (string constant)
                then at init-time, instead of parsing pax-designer to manifest, just load the string
                [Problem] this works for parsing — but it seems we will still need pax_designer in the module tree at runtime (probably build-time, too)
                so that e.g. event handlers & properties are present.
                This further suggests figuring out a way to reexport pax_designer through pax_engine, if possible...
            [-] could not import pax_engine inside pax_designer; instead directly reach into all reexported packages
                would enforce that pax_engine is a nice thin wrapper; nothing contained directly
                ^ going to give this a shot...
                [Nope], this tangles with the assumption that `pax_engine` exists at macro-time, which would break #[pax] inside
                pax-designer.  (could parameterize this symbol, but more complexity, esp. in generated cartridge)
            [-] could we bundle designer under pax-std?  The source of the circ ref is pax_designer -> pax_engine -> pax_designer, so [the issue remains]
            [ ] what about a new crate: pax-engine-without-designer.  pax-designer depends on this.  it is the current pax-engine crate.
                then pax-engine pub uses the above crate, as well as pax-designer
                finally, userland depends on pax-engine, and gets both crates

        Hypothesis: workspace is failing to build, and this is causing spurious errors
            - get workspace building,
            - come back and try `cargo run --bin=parser --features=parser,designtime` on fireworks

        rn pax-chassis-web has designtime OFF
        and pax-runtime has designtime ON
        start in fireworks, track down flags & deps; see who's breaking the chain

        [Solution] — default = ["designtime"] was added to pax-engine/Cargo.toml; was causing break
        [Solution cont.] — remove pax-designer from root workspace; enables building workspace without `--features designtime`
    
    [ ] Issue: we are including cartridge.partial.rs across every #[main], which e.g. causes build of pax-designer to fail
        when running Fireworks.

        Drafted solution:
            [x] detect whether we are in the root crate of this build.
            [x] might be able to store a static mutable Option<root_crate_pkg_name>, a write-once-read-many (WORM) signal to the rest of the build.
            [x] in the stpl template, check this signal and only include the partial if we are in the root crate. 
                [-] This might be fragile if somehow different versions of pax-macro are included in a build (is that possible or does cargo prevent it?) Answer: cargo prevents it. (answer ft. copilot)

        Note: as of current state, building without designtime requires omitting pax-designer as dependency. 
                might want to rewrap pax-engine-without-designer and pax-engine in another crate after all, to ease ergo here? (consolidating flags:  --feature=designer) 
                ^ this can happen in another pass after big merge

        Success will look like: can build fireworks and hopefully even run it; expected runtime crash

        Looks like there's an issue with `IS_DESIGNTIME_BUILD` definition — checking cfg within pax-compiler likely won't be useful.
        Probably should pass a runtime flag via CLI instead.
        ^ Resolved this but still hitting
        ```
        6 | #[pax]
        | ^^^^^^ use of undeclared crate or module `pax_designer`
        ```
        This is despite the fact that we're including pax_designer in the root crate.  Could it be because (a) the crate is failing to build,
        or (b) there's some corruption of features, or (c) because pax_designer isn't present in the workspace, even though it's available via the relative path specified in the root project's Cargo.toml?
        ^ This is because we're not including pax_designer in the root crate; it's only included in the pax-engine crate.  This is a problem because we need to include it in the root crate to get the #[pax] macro to work.
        


    [ ] Compiler-side: try-deserialize the tuple vs. the single manifest [probably make it a vec!  more extensible]
        
    [ ] Engine init logic (runtime)
        [ ] If in designtime build, render the root component via the designer; register the userland component for iframe



        
        
        

if we’re in main and designtime
(AND this is not PaxDesigner itself — note that this code will be included in #[main] logic,
which we’ll have at least two of: userland and designer)
then parse PaxDesigner to manifest alongside parsing the userland component tree
deserialize, then
initialize a definition_to_instance_traverser from each manifest (each of which surfaces a get_main_component)
the <PaxFrame> component just traverses this singular boundary (register-ed) for now; can make extensible later with different cartridges
the root component for the engine should be PaxDesigner; the inner component is the userland component


**Dev harness:**

*TL;DR examples should just work the same as `designer-project`*

Would be nice to have a dev harness mechanism for pax-designer through this flow.  I.e. similar to
the designer-project flow we have today.  We seem to lose this because we're retiring designer-project

In fact, given the current setup with relative paths inside the monorepo, we might get this for
free with all existing examples.

They use a relative path for pax-engine, which uses a relative path for pax-designer,
which will thus recompile and update as we libdev.

sed -e 's|^--- a/pax-design-server/|--- src/design_server/|' -e 's|^+++ b/pax-design-server/|+++ src/design_server/|' ../../pax-design-server.patch | git apply --3way

bookmark:

commit abe247a528e87a569f1cd5dd6333c9eb61ba8339
Author: Zack Brown <zack@pax.dev>
Date:   Mon Aug 12 15:45:14 2024 +0700

    draft of macro init logic













